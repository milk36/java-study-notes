GC调优相关工具
---
测试代码:
  ```java
  /**
   * 模拟风控程序; 从数据库中读取信用数据,套用模型,并把结果进行记录和传输 
   */

  public class T15_FullGC_Problem01 {

      private static class CardInfo {
          BigDecimal price = new BigDecimal(0.0);
          String name = "张三";
          int age = 5;
          Date birthdate = new Date();

          public void m() {}
      }

      private static ScheduledThreadPoolExecutor executor = new ScheduledThreadPoolExecutor(50,
              new ThreadPoolExecutor.DiscardOldestPolicy());

      public static void main(String[] args) throws Exception {
          executor.setMaximumPoolSize(50);

          for (;;){
              modelFit();
              Thread.sleep(100);
          }
      }

      private static void modelFit(){
          List<CardInfo> taskList = getAllCardInfo();
          taskList.forEach(info -> {
              // do something
              executor.scheduleWithFixedDelay(() -> {
                  //do sth with info
                  info.m();

              }, 2, 3, TimeUnit.SECONDS);
          });
      }

      private static List<CardInfo> getAllCardInfo(){
          List<CardInfo> taskList = new ArrayList<>();

          for (int i = 0; i < 100; i++) {
              CardInfo ci = new CardInfo();
              taskList.add(ci);
          }

          return taskList;
      }
  }

  ```
这个程序执行到最后会抛出异常 `OutOfMemoryError`

启动参数:`java -Xms200M -Xmx200M -XX:+PrintGC com.mashibing.jvm.gc.T15_FullGC_Problem01`
## JVM命令行工具
### jps
定位java相关进程信息
```
//输出指定参数列表
jps -v|awk '{print($1 $3)}'
```
### top
* top命令观察到问题; 内存不断增长 CPU占用率居高不下
* `top -Hp pid` 打印相关进程的线程信息; 观察进程中的线程,哪个线程CPU和内存占比高
### jstack
* 案例1 模拟长时间等待线程锁
  ```java
  public static void notifyTest() {
      Object lock = new Object();
      new Thread(() -> {
        synchronized (lock) {
          System.out.println("run:" + Thread.currentThread().getName());
          int count = 0;
          while (true) {
            for (int i = 0; i <Integer.MAX_VALUE; i++) {
              count++;
            }
            count = 0;
          }
        }
      }, "t1").start();

      new Thread(() -> {
        synchronized (lock) {
          System.out.println("run:" + Thread.currentThread().getName());
        }
      }, "t2").start();
    }
  ```
  `jstack pid`
  ```
  "t1" #21 prio=5 os_prio=0 cpu=32250.00ms elapsed=32.33s tid=0x000001c75eb31800 nid=0x8568 runnable  [0x0000003d9aefe000]
    java.lang.Thread.State: RUNNABLE
          at com.milk36.jvm.JStackCmdTest.lambda$notifyTest$0(JStackCmdTest.java:21)
          - locked <0x00000007194643b0> (a java.lang.Object)
          at com.milk36.jvm.JStackCmdTest$$Lambda$1/0x0000000800060840.run(Unknown Source)
          at java.lang.Thread.run(java.base@11.0.13/Thread.java:834)

  //观察可以看出 t2 申请的锁资源<0x00000007194643b0> 被 t1持有还没释放
  "t2" #22 prio=5 os_prio=0 cpu=0.00ms elapsed=32.33s tid=0x000001c75eb36800 nid=0x8560 waiting for monitor entry  [0x0000003d9afff000]
    java.lang.Thread.State: BLOCKED (on object monitor)
          at com.milk36.jvm.JStackCmdTest.lambda$notifyTest$1(JStackCmdTest.java:32)
          - waiting to lock <0x00000007194643b0> (a java.lang.Object)
          at com.milk36.jvm.JStackCmdTest$$Lambda$2/0x0000000800060c40.run(Unknown Source)
          at java.lang.Thread.run(java.base@11.0.13/Thread.java:834)

  ```
* 案例2 死锁
  ```java
  public static void main(String[] args) {
    Object lock1 = new Object();
    Object lock2 = new Object();
    new Thread(()->{
      System.out.println("start t1");
      synchronized (lock1) {
        HelperUtil.SleepHelper.secondsSleep(1);
        synchronized (lock2) {
          System.out.println("t1 succeed");
        }
      }
    },"Thread-1").start();

    new Thread(()->{
      System.out.println("start t1");
      synchronized (lock2) {
        HelperUtil.SleepHelper.secondsSleep(1);
        synchronized (lock1) {
          System.out.println("t2 succeed");
        }
      }
    },"Thread-2").start();
  }
  ```  
  ```
  "Thread-1" #21 prio=5 os_prio=0 cpu=0.00ms elapsed=76.06s tid=0x000001ce6c660000 nid=0x4bd4 waiting for monitor entry  [0x00000085e93fe000]
   java.lang.Thread.State: BLOCKED (on object monitor)
        at com.milk36.masibing.thinking.DeathLockTest.lambda$main$0(DeathLockTest.java:18)
        - waiting to lock <0x0000000719464530> (a java.lang.Object)
        - locked <0x0000000719464520> (a java.lang.Object)
        at com.milk36.masibing.thinking.DeathLockTest$$Lambda$1/0x0000000800060840.run(Unknown Source)
        at java.lang.Thread.run(java.base@11.0.13/Thread.java:834)

   Locked ownable synchronizers:
        - None

  "Thread-2" #22 prio=5 os_prio=0 cpu=0.00ms elapsed=76.06s tid=0x000001ce6c661800 nid=0x6ea8 waiting for monitor entry  [0x00000085e94fe000]
    java.lang.Thread.State: BLOCKED (on object monitor)
          at com.milk36.masibing.thinking.DeathLockTest.lambda$main$1(DeathLockTest.java:28)
          - waiting to lock <0x0000000719464520> (a java.lang.Object)
          - locked <0x0000000719464530> (a java.lang.Object)
          at com.milk36.masibing.thinking.DeathLockTest$$Lambda$2/0x0000000800060c40.run(Unknown Source)
          at java.lang.Thread.run(java.base@11.0.13/Thread.java:834)

    Locked ownable synchronizers:
          - None

  Found one Java-level deadlock:
  =============================
  "Thread-1":
    waiting to lock monitor 0x000001ce6c44ab00 (object 0x0000000719464530, a java.lang.Object),
    which is held by "Thread-2"
  "Thread-2":
    waiting to lock monitor 0x000001ce6c448b00 (object 0x0000000719464520, a java.lang.Object),
    which is held by "Thread-1"

  Java stack information for the threads listed above:
  ===================================================
  //观察可以看出双方都持有对方申请得锁 而得不到释放的机会
  "Thread-1":
          at com.milk36.masibing.thinking.DeathLockTest.lambda$main$0(DeathLockTest.java:18)
          - waiting to lock <0x0000000719464530> (a java.lang.Object)
          - locked <0x0000000719464520> (a java.lang.Object)
          at com.milk36.masibing.thinking.DeathLockTest$$Lambda$1/0x0000000800060840.run(Unknown Source)
          at java.lang.Thread.run(java.base@11.0.13/Thread.java:834)
  "Thread-2":
          at com.milk36.masibing.thinking.DeathLockTest.lambda$main$1(DeathLockTest.java:28)
          - waiting to lock <0x0000000719464520> (a java.lang.Object)
          - locked <0x0000000719464530> (a java.lang.Object)
          at com.milk36.masibing.thinking.DeathLockTest$$Lambda$2/0x0000000800060c40.run(Unknown Source)
          at java.lang.Thread.run(java.base@11.0.13/Thread.java:834)

  Found 1 deadlock.
  ```
* 分析思路
  * 十六进制的线程id `nid=0x8560` ,转成十进制可以对应到 `top -Hp pid`查看
  * 分析线程状态,jstack Dump文件的线程状态一般其实就以下3种
    1. RUNNABLE,线程处于执行中
    1. BLOCKED,线程被阻塞
    1. WAITING,线程正在等待
  * 重点关注 BLOCKED, WAITING 如:`java.lang.Thread.State: BLOCKED (on object monitor)`
  * 状态类型
    1. runnable，线程处于执行中
    1. deadlock，死锁（重点关注）
    1. blocked，线程被阻塞 （重点关注）
    1. Parked，停止
    1. locked，对象加锁
    1. waiting，线程正在等待
    1. waiting to lock 等待上锁
    1. Object.wait()，对象等待中
    1. waiting for monitor entry 等待获取监视器（重点关注）
    1. Waiting on condition，等待资源（重点关注），最常见的情况是线程在等待网络的读写
  * 查锁资源不释放
  
    查找等待锁对象持有者 `- waiting to lock <0x00000007194643b0> (a java.lang.Object)`

    看哪个线程持有这把锁 `- locked <0x00000007194643b0> (a java.lang.Object)` 状态位 `RUNNABLE`
  * 查死锁

    关注dump信息中是否有 `Found one Java-level deadlock` 
  * 通过观察 `jstack` dump 日志就能明白: _为什么阿里规范里规定，线程的名称（尤其是线程池）都要写有意义的名称_
  * 参考:[jstack命令解析](https://cloud.tencent.com/developer/article/1629157)
### jinfo
`jinfo pid` 打印启动参数等相关信息
### jstat
`jstat -gc pid interval` 动态观察gc情况 / 阅读GC日志发现频繁GC 

`jstat -gc 4655 500` - 每个500个毫秒打印GC的情况
### jconsole 或者 jvisualvm 远程连接
基于 JMX协议(Java Management Extensions)

* 监控目标程序配置启动参数
  ```shell
  java -Dcom.sun.management.jmxremote -Djava.rmi.server.hostname=192.168.11.190 -Dcom.sun.management.jmxremote.port=11111 -Dcom.sun.management.jmxremote.authenticate=false -Dcom.sun.management.jmxremote.ssl=false -Xms200M -Xmx200M -XX:+PrintGC FullGC_Problem01
  ```
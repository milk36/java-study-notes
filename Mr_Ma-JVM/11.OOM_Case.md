OOM 案例
---
### 线程池不当运用产生OOM问题
> OOM产生的原因多种多样, 有些程序未必产生OOM, 不断FGC(CPU飙高, 但每次内存回收空间非常少) -> T15_FullGC_Problem01 案例
>
> 线程池任务过多, 没有及时回收线程资源
### 硬件升级系统反而卡顿的问题
> 内存变大, 垃圾回收时间变长(STW), 更换垃圾回收器 PS + PO => CMS / G1

### new 大量线程，会产生 native thread OOM，（low）应该用线程池
  解决方案：减少堆空间（太low了）,预留更多内存产生 native thread

  JVM内存占物理内存比例 50% - 80%,剩余空间留给 native thread
### tomcat 设置`http-header-size`过大问题
```
server.max-http-header-size=10000000
```
tomcat 5的`http header size`的默认值是4K。
[关于springboot max-http-header-size最大长度的那些事及JVM调优](https://blog.csdn.net/yueaini10000/article/details/107809001)
### lambda表达式导致方法区溢出问题(MethodArea / Perm Metaspace)

`-XX:MaxMetaspaceSize=9M -XX:+PrintGCDetails` 设置元空间大小
```java
public static void main(String[] args) {
    for(;;) {
        I i = C::n;
    }
}
public static class C {
    static void n() {
        System.out.println("hello");
    }
}
```
方法区溢出日志:
```
Caused by: java.lang.OutOfMemoryError: Compressed class space
```
GC日志打印`Metadata GC`:
```
[Full GC (Metadata GC Threshold) [PSYoungGen: 128K->0K(77312K)] [ParOldGen: 1626K->1626K(1192448K)] 1754K->1626K(1269760K), [Metaspace: 8110K->8110K(1056768K)], 0.0106658 secs] [Times: user=0.20 sys=0.00, real=0.01 secs] 
```
解决方式
* 将元空间设置大一些 `-XX:MaxMetaspaceSize=512m`
* 
参考:
  
  [OutOfMemoryError系列（4）: Metaspace](https://blog.csdn.net/renfufei/article/details/78061354)

  [lambda 表达式每次执行时都会在堆上创建一个对象吗？](https://stackoverflow.com/questions/27524445/does-a-lambda-expression-create-an-object-on-the-heap-every-time-its-executed)
### 栈溢出问题 StackOverflowError
`-Xss`设定太小

递归调用, 将消耗完栈空间
```
public static void main(String[] args) {
    m();
}

static void m() {
    m();
}
```
打印异常:
```
Exception in thread "main" java.lang.StackOverflowError
```
### 参考

[OutOfMemoryError系列（1）: Java heap space](https://blog.csdn.net/renfufei/article/details/76350794)

[OutOfMemoryError系列（2）: GC overhead limit exceeded](https://blog.csdn.net/renfufei/article/details/77585294)

[OutOfMemoryError系列（3）: Permgen space](https://blog.csdn.net/renfufei/article/details/77994177)